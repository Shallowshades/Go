package main

import "fmt"

/*
Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用
一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径

每个包都对应一个独立的名字空间
要在外部引用该函数，必须显式使用package.Decode形式访问

包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息

在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的
因为汉字不区分大小写，因此汉字开头的名字是没有导出的

每个源文件都是以包的声明语句开始，用来指明包的名字。
当包被导入的时候，包内的成员将通过类似package.Xxx的形式访问。
包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。

导入包
	在Go语言程序中，每个包都有一个全局唯一的导入路径
	Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。
	当使用Go语言自带的go工具箱时，一个导入路径代表一个目录中的一个或多个Go源文件。
	除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定
	按照惯例，一个包的名字和包的导入路径的最后一个字段相同

	如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，因为删除一个类似log.Print("got here!")的打印语句可能导致需要同时删除log包导入声明，否则，编译器将会发出一个错误。在这种情况下，需要将不必要的导入删除或注释掉。
*/

/*
包的初始化

	包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化

	如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。

	对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数

	这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

	每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次
*/
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }

var pc [256]byte

/*
8位最大值为255
打表出每个值的1的个数

uint64 为64bit
分成8份 相加即可
*/
func BitTable() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1) //打表
		//i有多少个1 = i/2有多少个1 + 最后一位是不是1
	}
}

/*
练习 2.3： 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）
*/
func BitCount(x uint64) int {
	cnt := 0
	for i := 0; i < 8; i++ {
		cnt += int(pc[byte(x>>(i*8))])
	}
	return cnt
}

/*
练习 2.4： 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异
*/
func BitCountMove(x uint64) int {
	cnt := 0
	for x != 0 {
		cnt += int(x & 1)
		x >>= 1
	}
	return cnt
}

/*
练习 2.5： 表达式x&(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能
*/
func BitCountClear(x uint64) int {
	cnt := 0
	for x != 0 {
		x &= x - 1
		cnt++
	}
	return cnt
}

func Print() {
	for i, v := range pc {
		if i != 0 && i%16 == 0 {
			fmt.Println()
		}
		fmt.Print(v, " ")
	}
	fmt.Println()
}

func bs(n int) int {
	if 256+54*n > 64*n {
		return 1
	} else {
		return -1
	}
}

func main() {

	BitTable()
	Print()
	fmt.Printf("%o\n", 5435245674)
	fmt.Println(BitCount(5435245674))

	fmt.Println(BitCountMove(5435245674))
	fmt.Println(BitCountClear(5435245674))

	//256 + 8*N <= 64*N
	var l, r int = 0, 1e9 + 11
	for l <= r {
		//fmt.Println(l, " ", r)
		mid := (l + r) / 2
		ret := bs(mid)
		if ret == 1 {
			l = mid + 1
		} else {
			r = mid - 1
		}
	}
	fmt.Println(r + 1)
}
