package main

import (
	"fmt"
)

/*
	自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的）
	且只支持后置

	元组赋值
		gcd Fibonacci

	元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），

	但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。

	有些表达式会产生多个值，比如调用一个有多个返回值的函数。
	当这样一个函数调用出现在元组赋值右边的表达式中时（右边不能再有其它表达式），左边变量的数目必须和右边一致。
	当右侧为多返回值函数时，不可以再有更多的表达式，仅限该条多返回值函数存在

	map查找、类型断言或通道接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功
	但是并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。

	用下划线空白标识符_来丢弃不需要的值

可赋值性
	赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。

	map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。

	不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

	规则：
		类型必须完全匹配，
		nil可以赋值给任何指针或引用类型的变量
		常量有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。

	对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系
	对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然


*/

func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a%b
	}
	return a
}

// 0 1 1 2 3...
func fib(n int) int {
	a, b := 0, 1
	for i := 0; i < n; i++ {
		a, b = b, a+b
	}
	return a
}

func main() {

	x, y := gcd(3, 6), fib(4)
	fmt.Println(x, y)

	const N = 1000
	x = 1000
	if N == x {
		fmt.Println("x == N")
	} else {
		fmt.Println("x != N")
	}
}
