Abstract
We show how to derive imperative programs for relation-based discrete structures by combining relational calculus and the Dijkstra–Gries method. Three examples are given, viz. Warshall's algorithm for transitive closures, a breadth-first-search reachability algorithm, and an algorithm for spanning trees.

Introduction
Many discrete structures like graphs, Petri nets, and lattices are based on binary relations and, thus, computational tasks on them can be reduced to the computation of relational expressions. Based on early work by de Morgan, Peirce and Schröder since the middle of the nineteenth century, Tarski [22] proposed an axiomatic calculus of binary relations. To apply this tool for the calculational construction of correct programs on relation-based discrete structures from their specifications, a programmer, as a first step, has to translate the given problem into the language of relations. Then he has to choose a certain program development method and intertwine it with relation-algebraic calculations to derive the desired program.

In the last decade, various calculational approaches for programming with relations have been proposed. They can be discriminated by the way how the manipulation of relations is separated from the algorithmic principles involved. For instance, Möller and Russling use in a series of papers (see [13], [14], [15], for example) relations for calculating graph, sorting, and pointer algorithms. In doing so, they consider programs as well as the data which are manipulated by them as relations such that a separation is not given. There is another approach (some references are [1], [4], [19]) which considers relations only as data and manipulate them with conventional programming languages. Here the separation is very clear. Relations are also used as specification tool from which imperative programs formally are derived; see [11], [12], for example. In this third approach the separation is also very clear.

In this paper, we follow the second approach and use the well-known language of while programs for the description of algorithms. All expressions within such a program are from the datatype “relation” and the guards of conditionals and while-loops are propositional formulae over relations with inclusions or equations as atomic formulae. This specific choice also is motivated by our computer system RELVIEW [3], [5] which supports the same language and can, thus, be used for prototyping and executing programs. But mainly practical reasons speak for this kind of programs since it is very easy to translate them into efficient everyday programming languages like Modula or C.

For formally deriving correct imperative programs, the idea of using pre- and post-condition pairs as specifications and inductive assertions for synthesis is widespread. An early method is due to Dijkstra and Gries [7], [8], [9] and separates programs from specifications. In the refinement calculus [16] extending this method, there is no such separation. Using a specification statement, the derivation from the specification to the final program occurs within a single language. From a formal point of view this is an advantage. But the practising programmers seem to prefer the first style because it looks more “natural” and allows more freedom. For that reason, also in this paper we use the Dijkstra–Gries development method.

The paper is organized as follows: In Section 2, we recall some basic concepts of relational calculus, consider specific classes of relations and axiomatically introduce two (partial) choice operations on relations. Section 3 sketches the Dijkstra–Gries method and presents the proof obligations for the specific class of programs we are dealing with. In Section 4 we demonstrate by means of three examples how imperative relational programs formally can be derived by combining relational calculus and the Dijkstra–Gries method. Section 5 provides some concluding remarks.

Section snippets
Preliminaries
In this section, first we recall the basis concepts of the relational calculus used in this paper; see e.g., [6], [10], [20] for further details on this topic. Then we consider some specific classes of relations. Finally we introduce two choice operations on relations which are very important for advanced relational programming.

The Dijkstra–Gries method
In [9], Gries presents a methodology that aids to the construction of correct imperative programs from their specifications, where a specification consists of a pre-condition pre (describing the input restrictions) and a post-condition post (describing the results to be computed). It is based on the principle that “a program and its correctness proof should be developed hand-in-hand with the proof usually leading the way” (cf. [9, p. 164]) and can be seen as an elaboration of Dijkstra's pioneer 

Applications
In this section, we present the derivation of three relational programs applying relation-algebraic reasoning in combination with the Dijkstra–Gries method, viz. Warshall's algorithm for transitive closures, a breadth-first-search reachability algorithm, and an algorithm for spanning trees. As mentioned in Section 3, testing termination of while-loops via a measure function is a decisive part of the Dijkstra–Gries method. Therefore, we assume all carrier sets of the relations appearing in the

Conclusion
We have presented how to derive imperative programs for relation-based discrete structures by combining relational calculus and the Dijkstra–Gries method. Besides the operations of a relational algebra we use additional ones – in our examples the two choice operations  and  – which are defined by means of relation-algebraic formulae and exist for all concrete relations. The approach not only drastically reduces the danger of doing wrong steps. Since relational specifications and

Acknowledgements
I thank Ralf Behnke, Thorsten Hoffmann, and Jesus Ravelo for their helpful comments on an earlier version of this paper